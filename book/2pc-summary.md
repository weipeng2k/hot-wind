# 共识协议：两阶段提交

## 问题

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日常我们都有银行转账的经历，一个*用户A*从*银行X*的账户上转了**100元**到*用户B银行Y*的账户。如果单独分析*用户A*和*用户B*在各自银行账户的金额变化，它们就是独立的本地事务，但是由于这个场景是跨多个数据源，所以它是一个分布式事务场景，而分布式事务代表的是全局事务。

<center>
<img src="https://weipeng2k.github.io/hot-wind/resources/2pc-summary/bank-transfer.png" width="50%" />
</center>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图所示，*用户A*在*银行X*账户的扣款以及*用户B*在*银行Y*账户的存款是一个全局事务，它也符合事务的**ACID原则**，尤其是要兑现**原子性（Atomicity）**，也就是要么这两个操作全部成功，要么全部失败，没有中间状态。如果把这两个操作视作两个节点，在转账场景中，它们就形成了一个更大范畴的分布式系统（虽然*银行X和Y*的系统并不相同），而要确保分布式事务的原子性，需要保证：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）**安全性（Safety）**，所有节点共进退，要么成功，要么失败；

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）**存活性（Liveness）**，所有节点正常，则成功。可以允许有异常节点，但最终需要有一个一致结果，且不能一直等待。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参与分布式事务的多个节点需要对事务的提交或回滚达成一致，其实事务的提交与否和就一个值多节点达成一致，在本质上是同一回事，这就涉及到了分布式一致性问题。根据**CAP原理**，由于分区已经客观存在，保证安全性和存活性的必要条件就是保证一致性（Consistency），确保分区环境下的一致性的协议有许多，常见的就是两阶段提交（Two Phase Commit）。

## 协议

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两阶段提交协议为了为了保持跨多个节点全局事务的ACID特性，通过引入一个协调者组件来统一掌控所有节点（或称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。该协议的算法思路可以概括为：协调者先问询所有参与者的处理意见，参与者将结果通知到协调者；再由协调者根据所有反馈结果决定各参与者接下来是提交还是中止。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两阶段提交涉及到的角色一般有三个：*应用程序*、*协调者（或称作事务管理器）*和*参与者（或称作资源管理器）*。由*应用程序*发起操作，*协调者*一般是独立部署的中间件，而*参与者*是关系型数据库，*协调者*和*参与者*之间通过**XA协议**进行沟通。两阶段分为：准备阶段和提交阶段，分别应对投票和执行两个场景，其中准备阶段如下图所示：

<center>
<img src="https://weipeng2k.github.io/hot-wind/resources/2pc-summary/2PC-prepare-phase.png" width="50%" />
</center>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;准备阶段是由*应用程序*发起，通过*协调者*将提交事务的请求发送给所有*参与者*，*参与者*收到请求后在本地记录日志并将处理结果返回给*协调者*，然后等待最终命令，此时不做提交，对于外部数据变更是不可见的。处理结果只有两种，同意或中止。该阶段完成后，整体事务进入提交阶段，如下图所示：

<center>
<img src="https://weipeng2k.github.io/hot-wind/resources/2pc-summary/2PC-commit-phase.png" width="50%" />
</center>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*协调者*根据准备阶段收集到各*参与者*返回的处理结果集合进行判定，如果全部为同意，则向所有*参与者*发起提交命令，如果存在中止，则向所有*参与者*发起中止命令，当所有*参与者*响应命令后，整体事务完成。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到两阶段提交协议是一种非常朴素的分布式一致性协议，依靠*协调者*来协同各*参与者*，确保不同*参与者*的状态一致。在安全性上能够确保所有节点有一致的意愿，但是在存活性上是存在一些问题的，比如：*协调者*在事务执行中突然崩溃导致*参与者*出现悬停，接下来我们运用**CAP原理**和**拜占庭将军问题**分析一下二阶段提交的一些问题。

## 分析

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**CAP原理**指出，在一个分区的（分布式）系统中，无法同时满足一致性和可用性。两阶段提交协议面对分区选择了强一致性，因此在可用性上就会存在挑战和问题。选择强一致性，势必会在多个分区（或系统）之间同时锁定更多的资源，由于网络通信的不确定性，从而导致可用性降低。实际上二阶段提交最大的缺点就在于在执行时，参与节点都处于阻塞状态，节点之间相互等待对方的响应消息，而一旦某个节点锁定了某些资源后，其他（或非本事务）节点访问这些资源也会陷入阻塞状态，当然这也是保障一致性（隐性包含了可见性）的代价。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们将**拜占庭将军问题**的拓扑模型来演绎二阶段提交的执行场景，可以看出在该场景中，没有存在有意希望不达成共识的叛徒角色，所有*参与者*节点都是忠诚的。*协调者*扮演的是*指挥官*，而每个*参与者*就是*中尉*，*协调者*下达命令，*参与者*执行后反馈。由于各方通过消息（或者远程调用）进行沟通，而要形成共识，就需要对**假设1-3**能够满足，前两个假设比较容易解决，而两阶段提交面对的问题就在假设3的兑现上，也就是如何能发现对方（*协调者*或*参与者*）的消息缺失。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从*协调者*的角度去看，在准备阶段发起对各个*参与者*的请求后，就需要等待所有*参与者*的响应，如果某一个*参与者*未响应或者响应消息丢失，则**假设3**无法满足，无法达成共识，进而无法满足一致性。二阶段提交解决该问题的方式是增加*协调者*自身的超时机制，如果超时时间到达后，存在*参与者*没有响应，则通知所有*参与者*进行中止操作。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从*参与者*的角度去看，在提交阶段等待参与者的最终命令时，如果*协调者*此时出现故障导致未发送命令或者命令消息丢失，则也会导致一致性无法被满足。*参与者*也需要超时机制，在超时时间到达后，不能简单的做出提交或者中止的操作，而是需要同各个*参与者*进行协商，具体问题具体分析。比如：*协调者*可能没有发出命令，或者*协调者*可能发出了提交的命令，已经触达到了部分*参与者*后出现了问题。由于各个*参与者*不知道其他*参与者*在准备阶段的响应结果，所以就需要通信协商，而一旦涉及到*参与者*之间的通信，就会使这个问题变得更加复杂，最终很难有一个好的解决方案。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出两阶段提交通过引入*协调者*并利用准备和提交两个阶段简单的解决了分布式一致性问题，但在实际情况中，它却存在不少问题。两阶段提交要求对各*参与者*的资源占用时间横跨两个阶段，对资源占用时间过长导致吞吐量低，并且由于*协调者*（或部分*参与者*）稳定性或消息丢失问题，使得一旦出现问题，很难保证事务的一致性，只能提升*协调者*的可用性来减少问题的出现。
