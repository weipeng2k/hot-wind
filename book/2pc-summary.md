# 共识算法：两阶段提交协议

## 问题

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;日常我们都有银行转账的经历，一个*用户A*从*银行X*的账户上转了**100元**到*用户B银行Y*的账户。如果单独分析*用户A*和*用户B*在各自银行账户的金额变化，它们就是独立的本地事务，但是由于这个场景是跨多个数据源，所以它是一个分布式事务场景，而分布式事务代表的是全局事务。

<center>
<img src="https://weipeng2k.github.io/hot-wind/resources/2pc-summary/bank-transfer.png" width="50%" />
</center>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图所示，*用户A*在*银行X*账户的扣款以及*用户B*在*银行Y*账户的存款是一个全局事务，它也符合事务的**ACID原则**，尤其是要兑现**原子性（Atomic）**，也就是要么这两个操作全部成功，要么全部失败，没有中间状态。如果把这两个操作视作两个节点，在转账场景中，它们就形成了一个更大范畴的分布式系统（虽然*银行X和Y*的系统并不相同），而要确保分布式事务的原子性，需要保证：

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（1）**安全性（Safety）**，所有节点共进退，要么成功，要么失败；

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（2）**存活性（Liveness）**，所有节点正常，则成功。可以允许有异常节点，但最终需要有一个一致结果，且不能一直等待。

## 协议

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，二阶段提交也被称为是一种协议（Protocol）。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败 ，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（比如将更新后的数据写入磁盘等等）。因此，二阶段提交的算法思路可以概括为： 参与者将 操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。

## 分析
