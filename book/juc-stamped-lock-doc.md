# JUC中的StampedLock文档

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`StampedLock`是**Java8**新增的并发控制装置，它虽然是一个锁，但是没有实现`Lock`接口，在读多写少的场景下，它能够提供比`ReentrantReadWriteLock`更好的吞吐量。它的文档挺多，目前没有看到很好的翻译，这里我就做一下这个工作。

<center>
<img src="https://weipeng2k.github.io/hot-wind/resources/juc-summary/stamped-lock-banner.jpg">
</center>

一个基于功能的锁，它使用三种模式来控制读写访问。StampedLock的状态由版本和模式组成。获取锁的方法会返回一个戳记，该戳记用来表示锁的状态，同时在后续对锁的访问控制做出更改时，需要依赖该戳记，而这些访问控制以try开头的方法，如果接受戳记后返回一个0，则表示控制访问失败。释放和转换锁的方法都需要依赖传入戳记，如果戳记与锁的状态不一致，操作会失败返回。

> 戳记相当于一个印章，是对当前状态的一个摘要，如果戳记发生变化，与系统新生成的戳记不一致，这代表系统发生了变化。

三种模式分别是：

写模式。调用writeLock方法获取写锁，可能会由于排他访问而阻塞，该方法会返回一个戳记，同时也就获取到了写锁，当同步逻辑操作完成，使用unlockWrite进行解锁时，需要用到它。具备获取超时的tryWriteLock方法也有提供，当锁的状态为写模式，没有读锁可以被获取，同时所有乐观读锁的验证都会返回失败。

> writeLock与writeLockInterruptibly都是获取写锁，同时后者会响应中断。
> 乐观读锁的验证针对的是乐观读锁的操作步骤，获取乐观读锁后，在实际使用数据时，需要进行验证，这种两步走的操作方式基于读多于写的前提，提供更高的并发访问能力

读模式。调用readLock方法获取读锁，可能会由于非排他访问而阻塞，该方法会返回一个戳记，可以用来调用unlockRead进行解锁。具备获取超时的tryReadLock方法也有提供。

乐观读模式。当锁没有处于写模式时，方法tryOptimisticRead会返回一个非0的戳记，方法validate可以用来验证戳记，如果获取戳记后到验证前，锁没有进入过写模式，验证方法会返回true。该模式可以被看作是读模式的一个极度弱化的版本，只要有写操作，它就会被打破。乐观读模式在简短只读的代码片段上表现更好，因为它能减少竞争并提升吞吐量。但是乐观读用起来比较的凌乱，乐观读部分的代码只能将需要访问的字段读取存放到本地变量，然后再通过validate方法验证完成后，方可以使用。在乐观读模式下读取的数据可能非常不一致，需要使用者对数据非常清楚，并且通过反复调用validate方法进行验证。例如：当读取到对象或者数组时，在访问其字段、元素或者方法时，就需要使用这些步骤。

> 通过获取乐观读锁后，需要将数据保存到本地变量，然后在使用数据前，需要进行validate，只有validate通过，方能继续使用，也就是说这段时间数据的确没有写访问。

StampedLock也提供了有条件的模式转换方法。例如，tryConvertToWriteLock方法可以完成模式的升级，也就是转换到写模式，需要锁处于以下条件：
（1）已经处于写模式；
（2）在读模式中，但是当前没有其他的读取线程；
（3）在乐观读模式中，并且（写）锁可以被获取。
这些Convert类型的方法被设计用来减少用户手写重试转换的代码。

> 不仅有tryConvertToWriteLock的升级方法，也有转换到读或者乐观读的降级方法。
